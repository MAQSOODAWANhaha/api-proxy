# 调度策略与健康度设计文档

本文档旨在阐述 API 密钥池调度系统的核心设计理念，包括各种调度策略的侧重点，以及如何设计一个更合理的健康度评分模型。

## 1. 调度策略设计侧重点 (Philosophy)

系统应提供多种调度策略，每种策略都有其清晰的应用场景和侧重点。

### 轮询 (Round-Robin)

- **侧重点：** **绝对公平**。
- **核心思想：** 将请求严格、依次地平均分配给每个可用的密钥，不考虑任何其他因素。
- **优缺点：**
    - **优点：** 实现简单，负载绝对均衡，能确保所有密钥都得到使用。
    - **缺点：** “盲目”的公平。它无法区分密钥的实时表现，可能导致整体服务质量被性能最差的密钥拉低。
- **适用场景：** 当所有后端密钥的服务器性能、网络环境、账户配额都几乎相同时，轮询是简单高效的选择。

### 权重 (Weighted)

- **侧重点：** **按预设能力分配** (静态)。
- **核心思想：** 根据预设的权重值，按比例分配请求流量。权重越高的密钥，处理的请求越多。
- **优缺点：**
    - **优点：** 允许管理员根据密钥的“能力”（例如，付费版 vs 免费版）进行宏观调控，实现成本或性能的优化。
    - **缺点：** 权重是静态的，无法响应密钥的实时状态。如果一个高权重的密钥突然变得不健康，调度器依然会持续向它发送大量请求，造成请求失败。
- **适用场景：** 当后端密钥的能力有明确、固定的差异时（如不同的订阅套餐），可以使用权重来反映这种差异。

### 健康优先 (Health-Best)

- **侧重点：** **绝对可靠**。
- **核心思想：** 永远选择当前最健康的密钥来处理请求，以最大化单次请求的成功率。
- **优缺点：**
    - **优点：** 动态、响应式。能快速避开出问题的密钥，优先使用表现最好的密钥，提升系统可靠性。
    - **缺点：** 容易导致**“赢家通吃”**（Thundering Herd 问题）。如果一个密钥持续保持最健康，它将接收所有流量，直到它自己被流量压垮，然后流量瞬间切换到下一个“最健康”的密钥。这不仅没有做到负载均衡，还会加速消耗掉最优质的资源。
- **适用场景：** 对请求成功率要求极高，可以容忍负载不均衡的场景。

---

## 2. 健康度评分的合理设计

一个优秀的**综合健康分 (Comprehensive Health Score)** 是智能调度的基础。它应该是一个动态加权评分，综合以下几个维度：

1.  **近期成功率 (Success Rate):** 核心指标，应占据分数的大头（例如 **50%** 权重）。
    - **计算：** 基于最近 N 次健康检查的结果（如 N=20），计算 `成功次数 / N`。

2.  **延迟 (Latency):** 响应速度直接影响用户体验，建议占 **30%** 权重。
    - **计算：** 使用平均响应时间。可以设定一个“满意”区间（如 200-800ms）和“可容忍”上限（如 3000ms）。分数随延迟增加而平滑下降。
    - **示例公式：** `latency_score = if avg_ms < 200 { 30 } else if avg_ms > 3000 { 0 } else { 30 * (1 - (avg_ms - 200) / (3000 - 200)) }`

3.  **连续失败惩罚 (Consecutive Failure Penalty):** 连续失败是密钥即将失效的强烈信号，应施加一个**阶梯式或指数级的惩罚**，直接从总分中扣除。
    - **示例：** 0 次失败: 0分惩罚; 1 次失败: -10分; 2 次失败: -25分; 3 次及以上: -50分。

4.  **限流状态 (Rate Limit Status):**
    - 如果密钥处于 `rate_limited` 状态，其健康分应被强制设为一个非常低的值（例如 5-10分），但**不一定是 0**。这让它在没有其他可用密钥时仍有被选中的机会，但优先级远低于正常密钥。

**综合健康分公式（示例）:**
`Score = (SuccessRate * 50) + LatencyScore(30) - ConsecutiveFailurePenalty`
最终结果应约束在 0-100 范围内。`HealthBest` 策略应使用此综合分数进行排序。

---

## 3. 推荐算法：健康感知的加权轮询 (Health-Weighted Round-Robin)

将上述策略的优点结合，可以设计一种更智能的融合算法，作为系统的**默认推荐策略**。

### 算法步骤

1.  **过滤 (Filter):** 从密钥池中移除所有明确不可用的密钥（如 `is_active: false`，已过期，或 `health_status: "unhealthy"`）。

2.  **评分 (Score):** 为剩余的每个密钥计算其**综合健康分**（0-100），如上一节所述。

3.  **动态权重计算 (Dynamic Weighting):** 将用户配置的**静态权重**与实时的**健康分**结合，生成一个**动态权重**。这是算法的核心。
    ```rust
    // key.weight 是用户配置的静态权重
    // key.health_score 是计算出的综合健康分
    dynamic_weight = key.weight * (key.health_score / 100.0)
    ```
    - **效果：** 一个高静态权重的密钥，如果健康分下降，其动态权重也会随之降低，流向它的请求就会自动减少。

4.  **加权选择 (Weighted Selection):** 使用这些**动态权重**来执行一次加权选择（可复用 `Weighted` 策略的底层逻辑）。

### 融合算法的优势

- **尊重用户意图：** 基础流量分配由用户配置的 `weight` 决定。
- **动态适应：** `health_score` 像一个实时调节器，动态调整流量分配，奖励表现好的密钥，惩罚表现差的。
- **避免“赢家通吃”：** 只要有多个健康的密钥，它们都会根据其动态权重获得流量，实现了智能的负载均衡。
- **快速失败转移：** 一个密钥如果连续失败，其健康分会暴跌，动态权重也随之骤降，流量会迅速、平滑地转移到其他健康的密钥上。
